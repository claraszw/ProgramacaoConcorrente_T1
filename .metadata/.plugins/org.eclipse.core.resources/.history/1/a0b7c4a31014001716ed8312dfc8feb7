public class Filosofo implements Runnable {
	
	private static final Object forks_mutex = new Object();/* Esse mutex será utilizado para
	controlar o uso da variável "forks[]"*/
	public static final int N = 5;
	private static int forks[] = {-1,-1,-1,-1,-1}; /* Essa lista estática 
	irá armazenar o inteiro correspondende a id do filósofo que contém cada garfo.
	Se o garfo estiver na mesa, o valor será -1.*/
	private int id;
	
	public Filosofo(int id){
		this.id = id;
	}
	
	public void Think(){
		System.out.println("Filosofo " + this.id + " esta pensando");
		try{
			Thread.sleep(1000);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	public void Eat(){
		System.out.println("Filosofo " + this.id + " esta comendo");
		try{
			Thread.sleep(1000);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	/*
	 * i: número do garfo desejado.
	 * 
	 * Essa função é uma região crítica pois le e escreve valores da variável estática "forks",
	 * portanto, apenas uma thread poderá executá-la por vez.
	 * O Filosófo tentará adquirir o garfo i. Caso ele esteja disponível, armazena o valor de
	 *  sua própria id no índice do garfo e libera o mutex. Caso esteja com outro filósofo,
	 *  escolhe bloquear até que seja acordada pela devolução de um garfo, liberando o mutex.  
	 * */
	public void Take_fork(int i){
		synchronized(forks_mutex){
		System.out.println("Filosofo " + this.id + " vai tentar pegar o garfo " + i);
			while(forks[i]>=0){
				try {
					System.out.println("Filosofo " + this.id + " vai dormir. Garfo com o Filósofo " + forks[i]);
					forks_mutex.wait();
					System.out.println("Filosofo " + this.id + " acordou");
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
			System.out.println("Filosofo " + this.id + " pegou o garfo " + i);
			forks[i]=this.id;
		}	
	}
	
	/*
	 * i: garfo a ser devolvido
	 * Essa função é uma região crítica pois escreve na variável estática "forks",
	 * portanto, apenas uma thread poderá executá-la por vez.
	 * Seta o valor do garfo devolvido para -1, acorda threads que estejam bloqueadas
	 * e então libera o mutex.
	 * */
	public void Put_fork(int i){
		synchronized(forks_mutex){
		forks[i] = -1;
			System.out.println("Filosofo " + this.id + " vai devolver o garfo " + i);
			forks_mutex.notifyAll();
		}
	}
	
	
	/*
	 * O Filósofo repete a rotina de pensar, pegar separadamente os garfos, comer
	 * e devolver separadamente os garfos.
	 * */
	@Override
	public void run() {

		while(true){
			Think();
			Take_fork(this.id);
			Take_fork((this.id+1)%N);
			Eat();
			Put_fork(this.id);
			Put_fork((this.id+1)%N);
		}
		
	}
	
	

}
